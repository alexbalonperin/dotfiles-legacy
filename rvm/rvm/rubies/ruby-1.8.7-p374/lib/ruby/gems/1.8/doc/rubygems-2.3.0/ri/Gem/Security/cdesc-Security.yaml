--- !ruby/object:RI::ClassDescription 
attributes: []

class_methods: []

comment: 
- !ruby/struct:SM::Flow::H 
  level: 1
  text: Signing gems
- !ruby/struct:SM::Flow::P 
  body: The Gem::Security implements cryptographic signatures for gems. The section below is a step-by-step guide to using signed gems and generating your own.
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Walkthrough
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Building your certificate
- !ruby/struct:SM::Flow::P 
  body: "In order to start signing your gems, you'll need to build a private key and a self-signed certificate. Here's how:"
- !ruby/struct:SM::Flow::VERB 
  body: "  # build a private key and certificate for yourself:\n  $ gem cert --build you@example.com\n"
- !ruby/struct:SM::Flow::P 
  body: This could take anywhere from a few seconds to a minute or two, depending on the speed of your computer (public key algorithms aren't exactly the speediest crypto algorithms in the world). When it's finished, you'll see the files &quot;gem-private_key.pem&quot; and &quot;gem-public_cert.pem&quot; in the current directory.
- !ruby/struct:SM::Flow::P 
  body: "First things first: Move both files to ~/.gem if you don't already have a key and certificate in that directory. Ensure the file permissions make the key unreadable by others (by default the file is saved securely)."
- !ruby/struct:SM::Flow::P 
  body: "Keep your private key hidden; if it's compromised, someone can sign packages as you (note: PKI has ways of mitigating the risk of stolen keys; more on that later)."
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Signing Gems
- !ruby/struct:SM::Flow::P 
  body: In RubyGems 2 and newer there is no extra work to sign a gem. RubyGems will automatically find your key and certificate in your home directory and use them to sign newly packaged gems.
- !ruby/struct:SM::Flow::P 
  body: If your certificate is not self-signed (signed by a third party) RubyGems will attempt to load the certificate chain from the trusted certificates. Use <tt>gem cert --add signing_cert.pem</tt> to add your signers as trusted certificates. See below for further information on certificate chains.
- !ruby/struct:SM::Flow::P 
  body: "If you build your gem it will automatically be signed. If you peek inside your gem file, you'll see a couple of new files have been added:"
- !ruby/struct:SM::Flow::VERB 
  body: "  $ tar tf your-gem-1.0.gem\n  metadata.gz\n  metadata.gz.sum\n  metadata.gz.sig # metadata signature\n  data.tar.gz\n  data.tar.gz.sum\n  data.tar.gz.sig # data signature\n"
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Manually signing gems
- !ruby/struct:SM::Flow::P 
  body: "If you wish to store your key in a separate secure location you'll need to set your gems up for signing by hand. To do this, set the <tt>signing_key</tt> and <tt>cert_chain</tt> in the gemspec before packaging your gem:"
- !ruby/struct:SM::Flow::VERB 
  body: "  s.signing_key = '/secure/path/to/gem-private_key.pem'\n  s.cert_chain = %w[/secure/path/to/gem-public_cert.pem]\n"
- !ruby/struct:SM::Flow::P 
  body: When you package your gem with these options set RubyGems will automatically load your key and certificate from the secure paths.
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Signed gems and security policies
- !ruby/struct:SM::Flow::P 
  body: "Now let's verify the signature. Go ahead and install the gem, but add the following options: <tt>-P HighSecurity</tt>, like this:"
- !ruby/struct:SM::Flow::VERB 
  body: "  # install the gem with using the security policy &quot;HighSecurity&quot;\n  $ sudo gem install your.gem -P HighSecurity\n"
- !ruby/struct:SM::Flow::P 
  body: The <tt>-P</tt> option sets your security policy -- we'll talk about that in just a minute. Eh, what's this?
- !ruby/struct:SM::Flow::VERB 
  body: "  $ gem install -P HighSecurity your-gem-1.0.gem\n  ERROR:  While executing gem ... (Gem::Security::Exception)\n      root cert /CN=you/DC=example is not trusted\n"
- !ruby/struct:SM::Flow::P 
  body: "The culprit here is the security policy. RubyGems has several different security policies. Let's take a short break and go over the security policies. Here's a list of the available security policies, and a brief description of each one:"
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: NoSecurity - Well, no security at all. Signed packages are treated like unsigned packages.
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: LowSecurity - Pretty much no security. If a package is signed then RubyGems will make sure the signature matches the signing certificate, and that the signing certificate hasn't expired, but that's it. A malicious user could easily circumvent this kind of security.
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: MediumSecurity - Better than LowSecurity and NoSecurity, but still fallible. Package contents are verified against the signing certificate, and the signing certificate is checked for validity, and checked against the rest of the certificate chain (if you don't know what a certificate chain is, stay tuned, we'll get to that). The biggest improvement over LowSecurity is that MediumSecurity won't install packages that are signed by untrusted sources. Unfortunately, MediumSecurity still isn't totally secure -- a malicious user can still unpack the gem, strip the signatures, and distribute the gem unsigned.
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: HighSecurity - Here's the bugger that got us into this mess. The HighSecurity policy is identical to the MediumSecurity policy, except that it does not allow unsigned gems. A malicious user doesn't have a whole lot of options here; they can't modify the package contents without invalidating the signature, and they can't modify or remove signature or the signing certificate chain, or RubyGems will simply refuse to install the package. Oh well, maybe they'll have better luck causing problems for CPAN users instead :).
  type: :BULLET
- !ruby/struct:SM::Flow::P 
  body: "The reason RubyGems refused to install your shiny new signed gem was because it was from an untrusted source. Well, your code is infallible (naturally), so you need to add yourself as a trusted source:"
- !ruby/struct:SM::Flow::VERB 
  body: "  # add trusted certificate\n  gem cert --add ~/.gem/gem-public_cert.pem\n"
- !ruby/struct:SM::Flow::P 
  body: "You've now added your public certificate as a trusted source. Now you can install packages signed by your private key without any hassle. Let's try the install command above again:"
- !ruby/struct:SM::Flow::VERB 
  body: "  # install the gem with using the HighSecurity policy (and this time\n  # without any shenanigans)\n  $ gem install -P HighSecurity your-gem-1.0.gem\n  Successfully installed your-gem-1.0\n  1 gem installed\n"
- !ruby/struct:SM::Flow::P 
  body: This time RubyGems will accept your signed package and begin installing.
- !ruby/struct:SM::Flow::P 
  body: "While you're waiting for RubyGems to work it's magic, have a look at some of the other security commands by running <tt>gem help cert</tt>:"
- !ruby/struct:SM::Flow::VERB 
  body: "  Options:\n    -a, --add CERT                   Add a trusted certificate.\n    -l, --list [FILTER]              List trusted certificates where the\n                                     subject contains FILTER\n    -r, --remove FILTER              Remove trusted certificates where the\n                                     subject contains FILTER\n    -b, --build EMAIL_ADDR           Build private key and self-signed\n                                     certificate for EMAIL_ADDR\n    -C, --certificate CERT           Signing certificate for --sign\n    -K, --private-key KEY            Key for --sign or --build\n    -s, --sign CERT                  Signs CERT with the key from -K\n                                     and the certificate from -C\n"
- !ruby/struct:SM::Flow::P 
  body: We've already covered the <tt>--build</tt> option, and the <tt>--add</tt>, <tt>--list</tt>, and <tt>--remove</tt> commands seem fairly straightforward; they allow you to add, list, and remove the certificates in your trusted certificate list. But what's with this <tt>--sign</tt> option?
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Certificate chains
- !ruby/struct:SM::Flow::P 
  body: "To answer that question, let's take a look at &quot;certificate chains&quot;, a concept I mentioned earlier. There are a couple of problems with self-signed certificates: first of all, self-signed certificates don't offer a whole lot of security. Sure, the certificate says Yukihiro Matsumoto, but how do I know it was actually generated and signed by matz himself unless he gave me the certificate in person?"
- !ruby/struct:SM::Flow::P 
  body: The second problem is scalability. Sure, if there are 50 gem authors, then I have 50 trusted certificates, no problem. What if there are 500 gem authors? 1000? Having to constantly add new trusted certificates is a pain, and it actually makes the trust system less secure by encouraging RubyGems users to blindly trust new certificates.
- !ruby/struct:SM::Flow::P 
  body: "Here's where certificate chains come in. A certificate chain establishes an arbitrarily long chain of trust between an issuing certificate and a child certificate. So instead of trusting certificates on a per-developer basis, we use the PKI concept of certificate chains to build a logical hierarchy of trust. Here's a hypothetical example of a trust hierarchy based (roughly) on geography:"
- !ruby/struct:SM::Flow::VERB 
  body: "                        --------------------------\n                        | rubygems@rubygems.org |\n                        --------------------------\n                                    |\n                  -----------------------------------\n                  |                                 |\n      ----------------------------    -----------------------------\n      |  seattlerb@seattlerb.org |    | dcrubyists@richkilmer.com |\n      ----------------------------    -----------------------------\n           |                |                 |             |\n    ---------------   ----------------   -----------   --------------\n    |   drbrain   |   |   zenspider  |   | pabs@dc |   | tomcope@dc |\n    ---------------   ----------------   -----------   --------------\n"
- !ruby/struct:SM::Flow::P 
  body: Now, rather than having 4 trusted certificates (one for drbrain, zenspider, pabs@dc, and tomecope@dc), a user could actually get by with one certificate, the &quot;rubygems@rubygems.org&quot; certificate.
- !ruby/struct:SM::Flow::P 
  body: "Here's how it works:"
- !ruby/struct:SM::Flow::P 
  body: I install &quot;rdoc-3.12.gem&quot;, a package signed by &quot;drbrain&quot;. I've never heard of &quot;drbrain&quot;, but his certificate has a valid signature from the &quot;seattle.rb@seattlerb.org&quot; certificate, which in turn has a valid signature from the &quot;rubygems@rubygems.org&quot; certificate. Voila! At this point, it's much more reasonable for me to trust a package signed by &quot;drbrain&quot;, because I can establish a chain to &quot;rubygems@rubygems.org&quot;, which I do trust.
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Signing certificates
- !ruby/struct:SM::Flow::P 
  body: "The <tt>--sign</tt> option allows all this to happen. A developer creates their build certificate with the <tt>--build</tt> option, then has their certificate signed by taking it with them to their next regional Ruby meetup (in our hypothetical example), and it's signed there by the person holding the regional RubyGems signing certificate, which is signed at the next RubyConf by the holder of the top-level RubyGems certificate. At each point the issuer runs the same command:"
- !ruby/struct:SM::Flow::VERB 
  body: "  # sign a certificate with the specified key and certificate\n  # (note that this modifies client_cert.pem!)\n  $ gem cert -K /mnt/floppy/issuer-priv_key.pem -C issuer-pub_cert.pem\n     --sign client_cert.pem\n"
- !ruby/struct:SM::Flow::P 
  body: Then the holder of issued certificate (in this case, your buddy &quot;drbrain&quot;), can start using this signed certificate to sign RubyGems. By the way, in order to let everyone else know about his new fancy signed certificate, &quot;drbrain&quot; would save his newly signed certificate as <tt>~/.gem/gem-public_cert.pem</tt>
- !ruby/struct:SM::Flow::P 
  body: Obviously this RubyGems trust infrastructure doesn't exist yet. Also, in the &quot;real world&quot;, issuers actually generate the child certificate from a certificate request, rather than sign an existing certificate. And our hypothetical infrastructure is missing a certificate revocation system. These are that can be fixed in the future...
- !ruby/struct:SM::Flow::P 
  body: "At this point you should know how to do all of these new and interesting things:"
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: build a gem signing key and certificate
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: adjust your security policy
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: modify your trusted certificate list
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: sign a certificate
  type: :BULLET
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Manually verifying signatures
- !ruby/struct:SM::Flow::P 
  body: "In case you don't trust RubyGems you can verify gem signatures manually:"
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "1."
    body: Fetch and unpack the gem
  - !ruby/struct:SM::Flow::VERB 
    body: "  gem fetch some_signed_gem\n  tar -xf some_signed_gem-1.0.gem\n"
  - !ruby/struct:SM::Flow::LI 
    label: "2."
    body: Grab the public key from the gemspec
  - !ruby/struct:SM::Flow::VERB 
    body: "  gem spec some_signed_gem-1.0.gem cert_chain |  #        ruby -ryaml -e 'puts YAML.load_documents($stdin)' &gt; public_key.crt\n"
  - !ruby/struct:SM::Flow::LI 
    label: "3."
    body: Generate a SHA1 hash of the data.tar.gz
  - !ruby/struct:SM::Flow::VERB 
    body: "  openssl dgst -sha1 &lt; data.tar.gz &gt; my.hash\n"
  - !ruby/struct:SM::Flow::LI 
    label: "4."
    body: Verify the signature
  - !ruby/struct:SM::Flow::VERB 
    body: "  openssl rsautl -verify -inkey public_key.crt -certin  #        -in data.tar.gz.sig &gt; verified.hash\n"
  - !ruby/struct:SM::Flow::LI 
    label: "5."
    body: Compare your hash to the verified hash
  - !ruby/struct:SM::Flow::VERB 
    body: "  diff -s verified.hash my.hash\n"
  - !ruby/struct:SM::Flow::LI 
    label: "6."
    body: Repeat 5 and 6 with metadata.gz
  type: :NUMBER
- !ruby/struct:SM::Flow::H 
  level: 2
  text: OpenSSL Reference
- !ruby/struct:SM::Flow::P 
  body: "The .pem files generated by --build and --sign are PEM files. Here's a couple of useful OpenSSL commands for manipulating them:"
- !ruby/struct:SM::Flow::VERB 
  body: "  # convert a PEM format X509 certificate into DER format:\n  # (note: Windows .cer files are X509 certificates in DER format)\n  $ openssl x509 -in input.pem -outform der -out output.der\n\n  # print out the certificate in a human-readable format:\n  $ openssl x509 -in input.pem -noout -text\n"
- !ruby/struct:SM::Flow::P 
  body: "And you can do the same thing with the private key file as well:"
- !ruby/struct:SM::Flow::VERB 
  body: "  # convert a PEM format RSA key into DER format:\n  $ openssl rsa -in input_key.pem -outform der -out output_key.der\n\n  # print out the key in a human readable format:\n  $ openssl rsa -in input_key.pem -noout -text\n"
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Bugs/TODO
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: There's no way to define a system-wide trust list.
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: custom security policies (from a YAML file, etc)
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Simple method to generate a signed certificate request
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Support for OCSP, SCVP, CRLs, or some other form of cert status check (list is in order of preference)
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Support for encrypted private keys
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Some sort of semi-formal trust hierarchy (see long-winded explanation above)
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Path discovery (for gem certificate chains that don't have a self-signed root) -- by the way, since we don't have this, THE ROOT OF THE CERTIFICATE CHAIN MUST BE SELF SIGNED if Policy#verify_root is true (and it is for the MediumSecurity and HighSecurity policies)
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Better explanation of X509 naming (ie, we don't have to use email addresses)
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Honor AIA field (see note about OCSP above)
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Honor extension restrictions
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Might be better to store the certificate chain as a PKCS#7 or PKCS#12 file, instead of an array embedded in the metadata.
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Flexible signature and key algorithms, not hard-coded to RSA and SHA1.
  type: :BULLET
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Original author
- !ruby/struct:SM::Flow::P 
  body: Paul Duncan &lt;pabs@pablotron.org&gt; http://pablotron.org/
constants: []

full_name: Gem::Security
includes: []

instance_methods: []

name: Security
superclass: 
